# Bug Report: policy-zig sampling produces different results than policy-go / policy-rs

## Summary

After updating `policy-zig` from v0.1.9 to v0.1.10, the Zig conformance runner fails 3 of 4 probabilistic sampling test cases. The Go and Rust runners both pass all 4. The root cause is that `policy-zig`'s `TraceSampler.computeRandomness` produces different sampling decisions than `policy-go` and `policy-rs` for the same trace IDs.

## Failing Tests

| Test Case              | Expected kept | Zig kept | Go/Rust kept | Status |
|------------------------|---------------|----------|--------------|--------|
| `traces_sampling_10pct`| 1 span        | 0 spans  | 1 span       | FAIL   |
| `traces_sampling_25pct`| 2 spans       | 0 spans  | 2 spans      | FAIL   |
| `traces_sampling_50pct`| 3 spans       | 3 spans  | 3 spans      | PASS   |
| `traces_sampling_75pct`| 4 spans       | 5 spans  | 4 spans      | FAIL   |

The expected outputs were generated by the Go runner (which the Rust runner also matches).

## Test Setup

All 4 test cases use the same 5 input spans with these base64-encoded trace IDs (which decode to 16 raw bytes each):

| Span Name            | traceId (base64)                   |
|----------------------|------------------------------------|
| GET /api/users       | `qrvM3QAAAAAB/XCj1wo9cA==`        |
| GET /api/orders      | `qrvM3QAAAAACwAAAAAAAAA==`        |
| GET /api/products    | `qrvM3QAAAAADgAAAAAAAAA==`        |
| GET /api/inventory   | `qrvM3QAAAAAEQAAAAAAAAA==`        |
| GET /api/settings    | `qrvM3QAAAAAFDMzMzMzMzQ==`        |

The policy matches on `resource_attribute "service.name" == "api-server"` and applies `keep.percentage` at 10%, 25%, 50%, or 75%.

No explicit `mode`, `hash_seed`, or `sampling_precision` is set in the policy JSON — only `percentage` — so all defaults apply.

## Root Cause Analysis

All three runners pass **raw bytes** (16 bytes) to their respective policy engine's sampling function. The protobuf JSON decoders in all languages decode the base64 `traceId` field to raw bytes before the policy engine sees it.

**Note:** The Rust conformance runner decodes base64 to a **hex string** before passing it to `policy-rs`. This is a deliberate choice (`decode_base64_to_hex` in `runners/rs/src/eval.rs:145`). The Go and Zig runners both pass raw bytes. Despite this difference in representation, Go and Rust produce identical sampling decisions — meaning `policy-go` and `policy-rs` agree on the hashing. Only `policy-zig` disagrees.

The bug is in `policy-zig`'s `TraceSampler.computeRandomness` function (in `src/policy/trace_sampler.zig`). For a standard 16-byte trace ID, it:

1. Extracts the last 7 bytes (indices 9..16) → 56 bits of randomness
2. XORs with `hash_seed` (default 0)
3. Applies `mixHash` (splitmix64)
4. Masks to 56 bits
5. Compares against threshold: `T = floor((1 - percentage/100) * 2^56)`

The function that needs investigation:

```zig
fn computeRandomness(self: TraceSampler, trace_id: []const u8) u64 {
    var r: u64 = 0;
    if (trace_id.len >= 16) {
        for (trace_id[9..16]) |b| {
            r = (r << 8) | b;
        }
    } else if (trace_id.len > 0) {
        for (trace_id) |b| {
            r = (r << 8) ^ b;
        }
    }
    r ^= @as(u64, self.hash_seed);
    r = mixHash(r);
    return r & (MAX_56BIT - 1);
}
```

Something in this pipeline differs from the equivalent Go/Rust implementation. Possible causes:

1. **Different byte extraction range** — Go/Rust may use different indices or a different number of bytes from the trace ID.
2. **Different hash function or mixing** — The `mixHash`/splitmix64 implementation may differ, or Go/Rust may not apply a mixing step at all.
3. **Different threshold calculation** — The threshold formula may use different precision or rounding.
4. **Representation mismatch** — Since Rust passes hex strings (32 ASCII chars) and the function has a `trace_id.len >= 16` branch, Rust's policy engine likely treats the hex string differently (it's 32 bytes, not 16, so it extracts from different positions). If `policy-go` also expects hex-encoded trace IDs internally, then `policy-zig` receiving raw bytes would extract completely different randomness bits.

### Most Likely Cause

**Check whether `policy-go` internally converts raw bytes to hex before sampling.** If `policy-go`'s sampler operates on a 32-byte hex string (like `policy-rs` explicitly provides), then `policy-zig` receiving raw 16-byte trace IDs would extract bytes 9-15 of the raw data, while `policy-go` would extract bytes 9-15 of the hex representation — completely different values. This would explain why all three runners disagree on which spans to keep.

## How to Reproduce

```bash
# In the policy-conformance repo, with policy-zig v0.1.10:
task test:zig    # 65 passed, 3 failed
task test:go     # 68 passed, 0 failed
task test:rs     # 68 passed, 0 failed
```

## Suggested Fix

Align `policy-zig`'s `computeRandomness` with `policy-go`'s equivalent function so that given identical input bytes, both produce identical sampling decisions. Compare the Go implementation's sampling function step-by-step against the Zig implementation and ensure:

1. Same input representation (raw bytes vs hex)
2. Same byte extraction range
3. Same hash/mixing function
4. Same threshold calculation
